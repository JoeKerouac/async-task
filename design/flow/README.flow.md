# 流式任务执行引擎
## 核心设计
### 设计概要
流式任务执行引擎依赖于异步任务的调度能力，并在此之上实现了我们的流式任务执行引擎，流式任务分为两种，一种是无限流任务，一种是有限流（也叫有限集）任务，对于这两种任务，都有一个任务主表、N个任务节点表以及N个异步任务记录（异步任务就是异步任务框架的任务，与任务节点一一对应），不同的是，无限流任务只有起点，没有结束点，而对于有限集任务则是只有一个起点并且只有一个结束点；

### 详细设计

流式任务定义主表
- 流ID，对于有限流来说，该ID是随机生成的（使用特殊算法），而对于有限流来说，该ID是使用场景（最长30）+分组（最长100）生成的
- 流类型：无限流（Stream）、有限集（Set）
  - 无限流模型：无限流模型只能单链，也就是每个节点最多只能有一个父节点并且最多只能有一个子节点
  - 有限流模型：有限流模型允许复杂结构，一个节点可以有多个父节点和多个子节点
- 第一个任务ID；
- 最后一个任务ID；如果是无限流，则这个字段随时可以变；
- 任务状态：INIT、RUNNING、PENDING（尾节点如果时PENDING则任务是PENDING，否则是FINISH）、FINISH（只表示完成，具体每个节点状态需要自行查看）


流式任务节点表（实际任务使用异步任务框架保存）
- 节点ID
- 流ID
- 任务数据
- 任务处理器：用于处理节点任务的处理器，不同节点可以选用同一个处理器，也可以选用不同处理器；
- 失败策略（重试指定次数后仍然没有成功的才是失败）：1、挂起；2、继续往后执行；3、结束；
- 节点状态：INIT（只有无限流有这个状态）、WAIT（初始状态）、READY、RUNNING、PENDING、SUCCESS、ERROR
- 节点执行策略ID（用户需要注册策略bean，并且指定ID）
  - 全部父节点成功才能继续执行
  - 全部父节点完成才能继续执行（注意，这个与上边的区别就是这个只要求所有父节点执行完成，并不要求父节点执行成功，也就是说父节点失败也是可以的），第一个节点可以选用该策略；
  - 指定数量父节点执行成功才能继续执行
  - 指定父节点ID集合执行成功才能接续执行
  - 自定义策略（当前节点的每个父节点执行成功后都会回调，将当前所有父节点执行状态传过去，用户自行判断是否可以执行子节点）
- 策略上下文



节点关系表（允许一个子节点对多个父节点、多个子节点对一个父节点）
- 关系ID
- 流ID
- 父节点ID
- 子节点ID


规定：
- 终态不可修改（除非是PENDING，修改PENDING时需要同步修改该节点的所有子节点状态，同时需要走特殊API）
- 对于流式任务（无论是无限流还是有限集），整个链路应该只有一个起始节点和一个结束节点，同时不能有环，构建任务时检测是否有环;
- 节点ID为N/A表示NULL节点；
- 对于无限流任务，任务的层级关系确定后不能修改；


pending状态：
- 对于有限集来说，如果一个节点pending，可能会导致后续所有子节点pending，会实时更新子节点状态为pending，此时子节点任务状态是pending，但是对应的异步任务状态是WAIT；
- 对于无限流来说，如果一个节点pending后，整个任务会暂停执行，pending节点对应的异步任务状态是执行完毕，pending节点的子节点任务状态是WAIT，对应的异步任务状态也是WAIT；


系统启动：
- 无限流式任务：
  - 启动定时批处理任务；
- 有限集任务：
  - 无需做任务处理，等待异步任务调起我们的节点任务即可；



无限流式任务添加节点任务：
- 查询是否存在主任务
- 主任务如果不存在，尝试插入主任务（状态为RUNNING，并且没有第一个节点和最后一个节点），如果这里发生并发，那么将会抛出主键冲突，此时只需要重新从数据库查询主任务即可，以此来解决主任务插入冲突问题；
- 添加任务节点（跟主任务关联上），状态为INIT，表示任务还未关联；注意，这里与上一步添加主任务不必保证在同一个事务完成，因为主任务重复执行也只会插入一次；
- 主动提前触发定时批处理任务，将该节点添加到主任务链上；

定时批处理任务：批量将无限流任务（INIT状态的）加入主任务：PS：为什么这么设计而不是在添加节点时直接将其添加到任务链上？因为如果添加节点时就将其添加到任务链上，在高并发场景下性能支撑不了；
- 加任务处理锁，保证同一个进程中不会有并发；
- label-A: 开启事务（事务隔离级别应该为 TRANSACTION_READ_COMMITTED 或者更高，否则会出问题），准备批处理，一次最多处理100条，防止锁定时间过久；
- 锁主任务，保证多进程下不会并发；注意，这里可能会有超时异常（其他线程已经先CAS修改了，因为在事务中，所以会加锁，我们的事务会被卡），异常直接跳转到label-B；这里的锁定有可能因为其他事务而挂起，为什么还将CAS修改放在事务中而不是事务外？因为这样可以简化服务异常宕机时的处理，当服务宕机后事务自动回滚，主任务锁自动释放；
- 按照存储时间升序批量获取当前节点任务状态为INIT的任务
- 批量构建节点关系，将INIT的任务构建出一个新的任务链；
- 将主任务的最后一个节点修改为新构建的任务连的尾节点，同时修改节点关系表，注意在关系表中，原任务链中的最后一个节点与当前任务链的第一个节点的关系要最后插入；
- 重新修改主任务为RUNNING状态，放弃锁定；
- 判断当前主任务是否是第一次添加任务链，如果是，则调度下第一个任务；
- 判断原任务链的最后一个任务的状态，如果是执行完成，此时需要我们手动调度一下新任务链的第一个任务，因为此时如果不调度这个将永远没有机会调度，注意，该调度应该在事务中做；
- 结束事务
- 结束内存锁
- label-B: 从数据库捞取一个节点状态为INIT的任务，如果捞取到了则跳转到label-A，否则结束本轮任务；


无限流式任务执行（第一次执行）：
- 捞取INIT状态的主任务
- 将主任务CAS修改为RUNNING
- 获取主任务的第一个任务；
- label-A: 将待执行任务节点任务修改为READY，同时将对应的异步任务修改为READY；
- 异步任务调度执行节点任务（先判断任务状态，如果状态是执行完毕，直接跳转到节点结果处理）
- 节点执行完毕，修改节点状态为指定状态
- 处理节点执行结果，以下几种结果：
  - PENDING: 任务挂起
  - ERROR/SUCCESS: 获取该任务的下一个任务， 此时有两种情况：
    - 没有获取到下一个任务：加事务锁，锁定主任务，判断是否有下一个任务，如果没有则直接结束；
    - 获取到下一个任务：跳转到label-A


添加有限集任务：
- 用户传进任务结构
- 任务结构校验、解析
- 开启事务
- 保存主任务、任务节点、任务节点对应的异步任务（异步任务以WAIT状态插入）
- 对第一个异步任务进行调度（等待异步任务调度即可）
- 提交事务


对于有限集任务执行：
- 获取READY状态的主任务，修改主任务状态为RUNNING（cas修改）
- 加载当前任务模型（所有子节点都加载出来）
- 找到待执行节点任务；PS：广度优先找到所有可执行的节点任务，将其修改为READY状态，等待调度；

节点任务调度执行（注意，因为当前已经在异步任务框架中了，所以对于该节点的状态来说不会有并发问题）：
- 从数据库查询节点状态（可能是上次实际任务执行完毕，执行finish任务的时候导致）；
- 如果当前节点已经是终态，那么跳转到label-A处执行；
- 将待执行节点状态修改为RUNNING；
- 开始执行节点任务逻辑；
- 节点任务执行完毕，将该节点状态修改为SUCCESS/ERROR/PENDING；（可以在beforeFinish中执行，否则重试的场景还要自己实现）
- label-A: 找到该节点的所有子节点遍历： 
  - label-B: 如果有子节点，此时根据子节点状态有如下几种处理：
    - WAIT: 获取该节点的所有父节点（因为允许一个节点有多个父节点，所以这里要反查一下，注意，这里可能获取到的时失效的状态，但是不影响，因为如果这个节点获取到另外一个父节点状态延迟时，表示另外一个节点或者本节点状态肯定不延迟）,将该节点的所有父节点传入该节点的执行策略中，判断该节点是否可以执行，返回值有以下几种：
      - 返回UNKNOWN表示当前条件不足，无法判断，节点继续WAIT；
      - 返回READY表示可以执行，则将节点CAS设置为READY，同时将节点任务设置为READY，如果CAS设置失败则从数据库刷新状态，然后返回label-B；
      - 返回PENDING则表示挂起，则将节点修改为PENDING（节点任务还是WAIT状态），跳转到label-C：
    - label-C: PENDING/SUCCESS/ERROR（所有的终态），根据是否尾节点有如下两种处理: 
      - 非尾节点：回到label-A继续遍历该节点的子节点；
      - 尾节点：跳转到label-D；
    - READY/RUNNING: 无需处理，等待任务执行完毕回调处理；
  - label-D: 如果没有子节点：说明当前节点是尾节点，此时从头节点遍历是否还有任务在执行（此时会有并发场景，查询时任务正在执行，但是立即更新为了执行成功，这个不影响），如果有，则无需处理，等正在执行中的任务结束后会判断，否则将主任务修改为PENDING（如果当前尾节点是PENDING则修改为PENDING）或者FINISH（只要当前节点不是PENDING就修改为FINISH）


## 常见异常
- 任务执行中服务正常关闭：正常关闭理论上会等待异步任务完成，不会有问题；
- 任务执行中服务异常关闭（例如服务器掉电、kill -9等）：异步任务将会被卡在RUNNING状态，此时是没办法自行恢复的，需要我们人工处理；
- 任务执行过程中PENDING，此时需要监控告警，人工及时介入处理；
